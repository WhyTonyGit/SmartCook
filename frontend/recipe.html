<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Жаркое из говядины - SmartCook</title>
    <link rel="icon" href="/assets/brand/favicon.svg" type="image/svg+xml">

    <link rel="stylesheet" href="css/common.css">
    <style>
        .recipe-header {
            position: relative;
            margin-bottom: var(--spacing-lg);
        }

        .recipe-back {
            position: absolute;
            top: var(--spacing-md);
            left: var(--spacing-md);
            z-index: 10;
            width: 40px;
            height: 40px;
            border-radius: var(--radius-full);
            background: rgba(255, 255, 255, 0.9);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
        }

        .recipe-favorite {
            position: absolute;
            top: var(--spacing-md);
            right: var(--spacing-md);
            z-index: 10;
            width: 40px;
            height: 40px;
            border-radius: var(--radius-full);
            background: rgba(255, 255, 255, 0.9);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
        }

        .recipe-favorite.active {
            background: var(--color-primary);
        }

        .recipe-favorite svg {
            width: 20px;
            height: 20px;
            fill: var(--color-text-secondary);
        }

        .recipe-favorite.active svg {
            fill: white;
        }

        .recipe-main-image {
            width: 100%;
            height: 300px;
            object-fit: cover;
            border-radius: var(--radius-lg);
            background: var(--color-bg-tertiary);
        }

        .recipe-thumbnails {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
        }

        .recipe-thumbnail {
            width: 80px;
            height: 80px;
            border-radius: var(--radius-md);
            object-fit: cover;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color var(--transition-fast);
        }

        .recipe-thumbnail:hover,
        .recipe-thumbnail.active {
            border-color: var(--color-primary);
        }

        .recipe-title {
            font-size: var(--font-size-2xl);
            font-weight: var(--font-weight-bold);
            margin: var(--spacing-lg) 0 var(--spacing-md);
        }

        .recipe-meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            font-size: var(--font-size-sm);
            color: var(--color-text-secondary);
        }

        .recipe-section {
            background: var(--color-bg);
            padding: var(--spacing-lg);
            border-radius: var(--radius-lg);
            margin-bottom: var(--spacing-lg);
        }

        .recipe-section-title {
            font-size: var(--font-size-xl);
            font-weight: var(--font-weight-bold);
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        .ingredients-list {
            list-style: none;
        }

        .ingredient-item {
            display: flex;
            align-items: center;
            padding: var(--spacing-md) 0;
            border-bottom: 1px solid var(--color-border-light);
        }

        .ingredient-item:last-child {
            border-bottom: none;
        }

        .ingredient-name {
            flex: 1;
            font-size: var(--font-size-base);
        }

        .recipe-steps {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            padding-left: 1.2rem;
        }

        .recipe-steps li {
            padding-left: var(--spacing-sm);
        }

        .recipe-step-title {
            font-size: var(--font-size-lg);
            font-weight: var(--font-weight-semibold);
            margin-bottom: var(--spacing-xs);
        }

        .recipe-step-description {
            color: var(--color-text-secondary);
            line-height: 1.6;
            margin-bottom: var(--spacing-sm);
        }

        .rating-section {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .rating-stars-display {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .rating-input {
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
            z-index: 2;
            pointer-events: auto;
        }

        .rating-input * {
            pointer-events: auto;
        }

        .rating-input .star-rating-button {
            position: relative;
            z-index: 3;
            cursor: pointer;
        }

        .rating-actions {
            margin-top: var(--spacing-sm);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .rating-value {
            font-weight: var(--font-weight-semibold);
            margin-left: var(--spacing-sm);
        }

        .rating-reviews {
            color: var(--color-primary);
            text-decoration: underline;
            cursor: pointer;
        }

        .comment-item {
            padding: var(--spacing-md) 0;
            border-bottom: 1px solid var(--color-border-light);
        }

        .comment-item:last-child {
            border-bottom: none;
        }

        .comment-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .comment-author {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .comment-avatar {
            width: 32px;
            height: 32px;
            border-radius: var(--radius-full);
            background: var(--color-primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-size-sm);
        }

        .comment-username {
            font-weight: var(--font-weight-semibold);
            font-size: var(--font-size-sm);
        }

        .comment-date {
            font-size: var(--font-size-xs);
            color: var(--color-text-light);
        }

        .comment-text {
            color: var(--color-text);
            line-height: 1.6;
        }

        .comment-delete {
            background: none;
            border: none;
            color: var(--color-error);
            cursor: pointer;
            padding: var(--spacing-xs);
            min-width: 32px;
            min-height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-full);
        }

        .comment-delete:hover {
            background: rgba(220, 38, 38, 0.1);
        }

        @media (min-width: 1024px) {
            .recipe-detail-grid {
                display: grid;
                grid-template-columns: 1fr 400px;
                gap: var(--spacing-xl);
            }

            .recipe-main-image {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="app-shell">
        <main class="app-main">
            <div class="page-content">
                <div class="container">
                    <div id="recipe-content"></div>

                    <div class="recipe-section" id="comments-section">
                        <h2 class="recipe-section-title">Комментарии</h2>
                        <div id="comments-list"></div>
                        <div id="comment-form" style="display: none;">
                            <div class="form-group">
                                <textarea id="comment-text" placeholder="Оставьте комментарий..." rows="3"></textarea>
                            </div>
                            <button class="btn btn-primary" onclick="submitComment()">Отправить</button>
                        </div>
                        <p id="login-prompt" style="text-align: center; color: var(--color-text-secondary); padding: var(--spacing-lg);">
                            Войдите, чтобы оставить комментарий
                        </p>
                    </div>
                </div>
            </div>
        </main>
        <div id="bottom-nav"></div>
    </div>

    <script type="module">
        import { api } from './js/api.js';
        import { renderComment, renderStars } from './js/components.js';
        import { formatTime, formatRating, formatReviews, formatServings, showToast, showLoading } from './js/utils.js';
        import { applyImageFallbacks, setImageWithFallback, PLACEHOLDER_IMAGE } from './js/image.js';

        const recipeId = new URLSearchParams(window.location.search).get('id');
        let isFavorite = false;
        let currentUser = null;
        let userRating = 0;
        let hoverRating = null;
        let userRatingStorageKey = null;
        const STAR_PATH = 'M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z';

        function renderStarSvg(fillPercent, size, uid) {
            return `
                <svg class="star-icon" viewBox="0 0 24 24" aria-hidden="true" style="--star-size: ${size}px;">
                    <defs>
                        <linearGradient id="${uid}" x1="0%" x2="100%">
                            <stop offset="${fillPercent}%" stop-color="var(--star-fill)"></stop>
                            <stop offset="${fillPercent}%" stop-color="var(--star-empty)"></stop>
                        </linearGradient>
                    </defs>
                    <path d="${STAR_PATH}" fill="url(#${uid})"></path>
                </svg>
            `;
        }

        function renderRatingButtons(currentRating = 0) {
            const safeRating = Math.max(0, Math.min(Number(currentRating) || 0, 5));
            const uid = `rating-${Math.random().toString(36).slice(2, 9)}`;
            return [1, 2, 3, 4, 5].map((value, index) => {
                const fillPercent = value <= safeRating ? 100 : 0;
                const gradientId = `${uid}-${index}`;
                return `
                    <button class="star-rating-button" type="button" data-value="${value}" aria-label="Оценка ${value}">
                        ${renderStarSvg(fillPercent, 28, gradientId)}
                    </button>
                `;
            }).join('');
        }

        function getDisplayRating() {
            return hoverRating !== null ? hoverRating : userRating;
        }

        function updateRatingInput() {
            const container = document.getElementById('rating-input');
            if (!container) return;
            container.innerHTML = renderRatingButtons(getDisplayRating());
            bindRatingInputEvents();
            bindRatingButtonEvents(container);
        }

        function previewRating(value) {
            if (hoverRating === value) return;
            hoverRating = value;
            updateRatingInput();
        }

        function resetRatingPreview() {
            hoverRating = null;
            updateRatingInput();
        }

        function bindRatingInputEvents() {
            const container = document.getElementById('rating-input');
            if (!container || container.dataset.bound === 'true') return;
            container.dataset.bound = 'true';

            container.addEventListener('mouseleave', () => {
                resetRatingPreview();
            });

            container.addEventListener('focusout', (event) => {
                if (!container.contains(event.relatedTarget)) {
                    resetRatingPreview();
                }
            });
        }

        function bindRatingButtonEvents(container) {
            const buttons = container.querySelectorAll('.star-rating-button');
            buttons.forEach((button) => {
                const value = Number(button.dataset.value);
                if (!Number.isFinite(value)) return;

                button.addEventListener('pointerenter', () => {
                    previewRating(value);
                });

                button.addEventListener('focus', () => {
                    previewRating(value);
                });

                button.addEventListener('pointerdown', (event) => {
                    event.preventDefault();
                    setRating(value);
                });

                button.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        setRating(value);
                    }
                });
            });
        }

        function updateDeleteButton() {
            const deleteBtn = document.getElementById('delete-rating-btn');
            if (deleteBtn) {
                deleteBtn.style.display = userRating ? 'inline-flex' : 'none';
            }
        }

        function getUserRatingKey() {
            if (currentUser?.id) {
                return `ratings:user:${currentUser.id}`;
            }
            if (currentUser?.email) {
                return `ratings:email:${currentUser.email}`;
            }
            return 'ratings:guest';
        }

        function readStoredRatingsForKey(key) {
            if (!key) return {};
            try {
                return JSON.parse(localStorage.getItem(key)) || {};
            } catch (e) {
                return {};
            }
        }

        function setUserRatingStorageKey(nextKey) {
            if (!nextKey) return;
            if (userRatingStorageKey && userRatingStorageKey !== nextKey) {
                const currentRatings = readStoredRatingsForKey(userRatingStorageKey);
                const nextRatings = readStoredRatingsForKey(nextKey);
                localStorage.setItem(nextKey, JSON.stringify({ ...currentRatings, ...nextRatings }));
            }
            userRatingStorageKey = nextKey;
        }

        function readStoredRatings() {
            return readStoredRatingsForKey(userRatingStorageKey);
        }

        function writeStoredRating(recipeIdValue, ratingValue) {
            if (!userRatingStorageKey) return;
            const ratings = readStoredRatings();
            ratings[recipeIdValue] = ratingValue;
            localStorage.setItem(userRatingStorageKey, JSON.stringify(ratings));
        }

        function removeStoredRating(recipeIdValue) {
            if (!userRatingStorageKey) return;
            const ratings = readStoredRatings();
            delete ratings[recipeIdValue];
            localStorage.setItem(userRatingStorageKey, JSON.stringify(ratings));
        }

        async function refreshRatingSummary() {
            try {
                const recipe = await api.getRecipe(recipeId);
                const summary = document.getElementById('rating-summary');
                if (summary) {
                    summary.innerHTML = `
                        <div class="rating-stars-display">
                            ${renderStars(recipe.avg_rating ?? 0, 5, { size: 18 })}
                        </div>
                        <span class="rating-value">${formatRating(recipe.avg_rating ?? 0)}</span>
                        <span class="rating-reviews">${formatReviews(recipe.comments_count || 0)}</span>
                    `;
                }
            } catch (e) {
                console.error('Failed to refresh rating summary:', e);
            }
        }

        async function init() {
            if (!recipeId) {
                document.getElementById('recipe-content').innerHTML = 
                    '<div class="alert alert-error">Рецепт не найден</div>';
                return;
            }

            // Проверка авторизации
            const token = api.getToken();
            if (token) {
                setUserRatingStorageKey(getUserRatingKey());
                try {
                    currentUser = await api.getProfile();
                    setUserRatingStorageKey(getUserRatingKey());
                    await loadUserRating();
                } catch (e) {
                    console.error('Failed to load user data:', e);
                    await loadUserRating();
                }
            }

            await loadRecipe();
        }

        async function loadRecipe() {
            showLoading(document.getElementById('recipe-content'));

            try {
                const recipe = await api.getRecipe(recipeId);
                displayRecipe(recipe);

                // Добавляем в историю, если авторизован
                if (api.getToken()) {
                    try {
                        await api.addToHistory(recipeId);
                    } catch (e) {
                        console.error('Failed to add to history:', e);
                    }
                }

                await loadComments();
                await checkFavorite();
            } catch (error) {
                document.getElementById('recipe-content').innerHTML = 
                    `<div class="alert alert-error">${error.message || 'Не удалось загрузить рецепт'}</div>`;
            }
        }

        function displayRecipe(recipe) {
            const container = document.getElementById('recipe-content');
            const mainImage = recipe.image_url || '';
            
            container.innerHTML = `
                <div class="recipe-header">
                    <button class="recipe-back" onclick="window.history.back()">
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
                            <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                        </svg>
                    </button>
                    <button class="recipe-favorite ${isFavorite ? 'active' : ''}" onclick="toggleFavorite()" id="favorite-btn" style="${api.getToken() ? '' : 'display: none;'}">
                        <svg viewBox="0 0 24 24">
                            <path d="${isFavorite ? 'M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z' : 'M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z'}"/>
                        </svg>
                    </button>
                    <img src="${PLACEHOLDER_IMAGE}" data-image-url="${mainImage}" data-image-name="${recipe.title}" data-image-type="recipe" alt="${recipe.title}" class="recipe-main-image" id="main-image">
                    ${recipe.steps && recipe.steps.some(s => s.image_url) ? `
                        <div class="recipe-thumbnails">
                            ${recipe.steps.filter(s => s.image_url).slice(0, 3).map((step, idx) => `
                                <img src="${PLACEHOLDER_IMAGE}" data-image-url="${step.image_url}" alt="Шаг ${step.number}" class="recipe-thumbnail ${idx === 0 ? 'active' : ''}" 
                                     onclick="changeMainImage('${step.image_url.replace(/'/g, "\\'")}')">
                            `).join('')}
                        </div>
                    ` : ''}
                </div>

                <h1 class="recipe-title">${recipe.title}</h1>

                <div class="recipe-meta">
                    <div class="rating-section" id="rating-summary">
                        <div class="rating-stars-display">
                            ${renderStars(recipe.avg_rating ?? 0, 5, { size: 18 })}
                        </div>
                        <span class="rating-value">${formatRating(recipe.avg_rating ?? 0)}</span>
                        <span class="rating-reviews">${formatReviews(recipe.comments_count || 0)}</span>
                    </div>
                    <span>⏱ ${formatTime(recipe.cooking_time)}</span>
                    <span>${formatServings(5)}</span>
                    <span>${recipe.difficulty}</span>
                </div>

                ${recipe.description ? `
                    <div class="recipe-section">
                        <p style="line-height: 1.6; color: var(--color-text-secondary);">${recipe.description}</p>
                    </div>
                ` : ''}

                <div class="recipe-section">
                    <h3 class="recipe-section-title">Ингредиенты:</h3>
                    <ul class="ingredients-list">
                        ${recipe.ingredients.map(ing => `
                            <li class="ingredient-item">
                                <span class="ingredient-name">${ing.name}</span>
                            </li>
                        `).join('')}
                    </ul>
                </div>

                ${recipe.steps && recipe.steps.length > 0 ? `
                    <div class="recipe-section">
                        <h3 class="recipe-section-title">Как готовить?</h3>
                        <ol class="recipe-steps">
                            ${recipe.steps.map(step => `
                                <li>
                                    <div class="recipe-step-title">${step.title}</div>
                                    <p class="recipe-step-description">${step.description}</p>
                                </li>
                            `).join('')}
                        </ol>
                    </div>
                ` : ''}

                ${recipe.missing_ingredients && recipe.missing_ingredients.length > 0 ? `
                    <div class="recipe-section">
                        <div class="recipe-card-status missing">
                            ! Нужно докупить: ${recipe.missing_ingredients.map(ing => ing.name).join(', ')}
                        </div>
                    </div>
                ` : ''}

                ${api.getToken() ? `
                    <div class="recipe-section">
                        <h3 class="recipe-section-title">Оцените рецепт</h3>
                        <div class="rating-input" id="rating-input">
                            ${renderRatingButtons(userRating)}
                        </div>
                        <div class="rating-actions">
                            <button class="btn btn-outline" id="delete-rating-btn" onclick="deleteRating()" style="${userRating ? '' : 'display: none;'}">
                                Удалить оценку
                            </button>
                        </div>
                    </div>
                ` : ''}
            `;
            applyImageFallbacks(container);
            updateRatingInput();
            updateDeleteButton();

            // Показываем форму комментариев если авторизован
            if (api.getToken()) {
                document.getElementById('comment-form').style.display = 'block';
                document.getElementById('login-prompt').style.display = 'none';
            }
        }

        function changeMainImage(url) {
            const mainImageEl = document.getElementById('main-image');
            setImageWithFallback(mainImageEl, url);
            document.querySelectorAll('.recipe-thumbnail').forEach(thumb => {
                thumb.classList.toggle('active', thumb.dataset.imageUrl === url);
            });
        }

        async function checkFavorite() {
            if (!api.getToken()) return;
            
            try {
                const favorites = await api.getFavorites();
                isFavorite = favorites.some(r => r.id === parseInt(recipeId));
                updateFavoriteButton();
            } catch (e) {
                console.error('Failed to check favorite:', e);
            }
        }

        function updateFavoriteButton() {
            const btn = document.getElementById('favorite-btn');
            if (!btn) return;
            
            if (isFavorite) {
                btn.classList.add('active');
                btn.querySelector('svg path').setAttribute('d', 'M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z');
            } else {
                btn.classList.remove('active');
                btn.querySelector('svg path').setAttribute('d', 'M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z');
            }
        }

        async function toggleFavorite() {
            if (!api.getToken()) {
                window.location.href = 'login.html';
                return;
            }

            try {
                if (isFavorite) {
                    await api.removeFavorite(recipeId);
                    isFavorite = false;
                } else {
                    await api.addFavorite(recipeId);
                    isFavorite = true;
                }
                updateFavoriteButton();
                showToast(isFavorite ? 'Добавлено в избранное' : 'Удалено из избранного', 'success');
            } catch (error) {
                showToast('Ошибка обновления избранного', 'error');
            }
        }

        async function loadUserRating() {
            try {
                const marks = await api.getMarks();
                const mark = marks.find(m => m.recipe_id === parseInt(recipeId));
                if (mark) {
                    userRating = mark.value;
                    return;
                }
                const storedRatings = readStoredRatings();
                if (storedRatings[recipeId]) {
                    userRating = storedRatings[recipeId];
                }
            } catch (e) {
                const storedRatings = readStoredRatings();
                if (storedRatings[recipeId]) {
                    userRating = storedRatings[recipeId];
                }
            }
        }

        async function setRating(value) {
            if (!api.getToken()) {
                window.location.href = 'login.html';
                return;
            }
            if (!recipeId) {
                showToast('Не удалось определить рецепт', 'error');
                return;
            }

            userRating = value;
            let storedLocally = false;
            try {
                writeStoredRating(recipeId, value);
                storedLocally = true;
            } catch (error) {
                storedLocally = false;
            }
            hoverRating = null;
            updateRatingInput();
            updateDeleteButton();

            try {
                await api.upsertMark(recipeId, value);
                await refreshRatingSummary();
                showToast('Оценка успешно сохранена', 'success');
            } catch (error) {
                if (storedLocally) {
                    showToast('Оценка успешно сохранена', 'success');
                } else {
                    showToast('Не удалось сохранить оценку', 'error');
                }
            }
        }

        async function deleteRating() {
            if (!api.getToken()) {
                window.location.href = 'login.html';
                return;
            }

            if (!confirm('Удалить оценку?')) return;

            try {
                await api.deleteMark(recipeId);
                userRating = 0;
                removeStoredRating(recipeId);
                hoverRating = null;
                updateRatingInput();
                updateDeleteButton();
                await refreshRatingSummary();
                showToast('Оценка удалена', 'success');
            } catch (error) {
                userRating = 0;
                removeStoredRating(recipeId);
                hoverRating = null;
                updateRatingInput();
                updateDeleteButton();
                showToast('Оценка удалена локально', 'info');
            }
        }

        async function loadComments() {
            try {
                const comments = await api.getComments(recipeId);
                displayComments(comments);
            } catch (error) {
                console.error('Failed to load comments:', error);
                document.getElementById('comments-list').innerHTML = '<p>Не удалось загрузить комментарии</p>';
            }
        }

        function displayComments(comments) {
            const container = document.getElementById('comments-list');
            if (!comments || comments.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: var(--color-text-secondary); padding: var(--spacing-lg);">Комментариев пока нет</p>';
                return;
            }

            container.innerHTML = comments.map(comment => {
                const canDelete = currentUser && (currentUser.id === comment.consumer_id || currentUser.role_id === 1);
                return renderComment(comment, {
                    showDelete: canDelete,
                    onDelete: canDelete ? `deleteComment(${comment.id})` : null,
                    currentUserId: currentUser?.id
                });
            }).join('');
        }

        async function deleteComment(commentId) {
            if (!confirm('Удалить комментарий?')) return;

            try {
                await api.deleteComment(commentId);
                showToast('Комментарий удален', 'success');
                loadComments();
            } catch (error) {
                showToast('Ошибка удаления комментария', 'error');
            }
        }

        async function submitComment() {
            if (!api.getToken()) {
                window.location.href = 'login.html';
                return;
            }

            const text = document.getElementById('comment-text').value.trim();
            if (!text) {
                showToast('Введите текст комментария', 'info');
                return;
            }

            try {
                await api.createComment(recipeId, text);
                document.getElementById('comment-text').value = '';
                showToast('Комментарий добавлен', 'success');
                loadComments();
            } catch (error) {
                showToast(error.message || 'Ошибка добавления комментария', 'error');
            }
        }

        window.toggleFavorite = toggleFavorite;
        window.setRating = setRating;
        window.deleteRating = deleteRating;
        window.previewRating = previewRating;
        window.resetRatingPreview = resetRatingPreview;
        window.submitComment = submitComment;
        window.deleteComment = deleteComment;
        window.changeMainImage = changeMainImage;

        init();
    </script>

    <script type="module">
        import { renderBottomNav } from './js/components.js';
        const navContainer = document.getElementById('bottom-nav');
        if (navContainer) {
            navContainer.innerHTML = renderBottomNav('');
        } else {
            document.body.insertAdjacentHTML('beforeend', renderBottomNav(''));
        }
    </script>
</body>
</html>
